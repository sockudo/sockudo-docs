---
title: Cache
description: Caching backends for app lookups, rate limiting, and general key-value storage.
navigation:
  icon: i-lucide-hard-drive
---

The cache system provides a key-value store with TTL support. It is used internally for rate limiting state and can be used by other subsystems that need fast lookups.

::callout{type="info"}
This is the **global cache driver** configured under `cache`. The [App Manager](/server/app-managers) has its own separate caching layer configured under `app_manager.cache`.
::

## Drivers

| Driver | Best For | Persistence | Shared Across Nodes |
|---|---|---|---|
| `memory` | Single-node, development | None | No |
| `redis` | Multi-node production | Yes | Yes |
| `redis-cluster` | Large-scale Redis Cluster | Yes | Yes |
| `none` | Disable caching | N/A | N/A |

Set the driver:

```bash
CACHE_DRIVER=memory
```

```json
{ "cache": { "driver": "memory" } }
```

## Memory Cache

In-process cache using [Moka](https://github.com/moka-rs/moka), a high-performance concurrent cache.

```json
{
  "cache": {
    "driver": "memory",
    "memory": {
      "ttl": 300,
      "cleanup_interval": 60,
      "max_capacity": 10000
    }
  }
}
```

| Setting | Default | Description |
|---|---|---|
| `ttl` | `300` | Global TTL in seconds (0 = no expiry) |
| `cleanup_interval` | `60` | Cleanup interval in seconds |
| `max_capacity` | `10000` | Maximum number of entries |

The memory cache is fast but **node-local** - each Sockudo instance has its own independent cache. This is fine for single-node deployments but means multi-node setups won't share cache state.

## Redis Cache

Shared cache using Redis. All Sockudo nodes read from and write to the same Redis instance, ensuring consistency across the cluster.

```json
{
  "cache": {
    "driver": "redis",
    "redis": {
      "prefix": "sockudo_cache:",
      "url_override": null,
      "cluster_mode": false
    }
  }
}
```

| Setting | Default | Description |
|---|---|---|
| `prefix` | `sockudo_cache:` | Redis key prefix |
| `url_override` | `null` | Override Redis URL (otherwise uses `database.redis`) |
| `cluster_mode` | `false` | Use cluster-aware connections |

Redis cache supports per-key TTL via `SET EX` and additional bulk operations (`MGET`, `MSET`).

## Redis Cluster Cache

Same as Redis cache but uses Redis Cluster connections. Use this when your Redis infrastructure runs in cluster mode.

```json
{
  "cache": {
    "driver": "redis-cluster",
    "redis": {
      "prefix": "sockudo_cache:",
      "cluster_mode": true
    }
  }
}
```

## Global Cache Tuning

These environment variables adjust cache behavior across multiple subsystems at once:

| Env Var | Default | Affects |
|---|---|---|
| `CACHE_TTL_SECONDS` | `300` | App manager cache, channel limits, DB caches, memory cache |
| `CACHE_CLEANUP_INTERVAL` | `60` | MySQL/PostgreSQL caches, memory cache |
| `CACHE_MAX_CAPACITY` | `10000` | MySQL/PostgreSQL caches, memory cache |

## Choosing a Driver

| Scenario | Recommended Driver |
|---|---|
| Development / single-node | `memory` |
| Multi-node production | `redis` |
| Redis Cluster infrastructure | `redis-cluster` |
| Cache not needed | `none` |

::callout{type="tip"}
When using `redis` for the adapter, use `redis` for the cache driver too. The `REDIS_URL` env var configures all Redis connections at once.
::
